<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Athlete Performance Analyzer</title>
    <!-- Include Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f7f6;
            color: #333;
            margin: 0;
            padding: 20px;
        }
        #app-container {
            max-width: 1200px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }
        header {
            background: #0052cc;
            color: white;
            padding: 20px 30px;
        }
        header h1 {
            margin: 0;
            font-size: 1.8em;
        }
        
        /* Loading Status */
        #loading-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            padding: 30px;
            background-color: #fafdff;
            border-bottom: 1px solid #eee;
        }
        .loading-item {
            border: 3px dashed #b0c4de;
            border-radius: 8px;
            padding: 30px 20px;
            text-align: center;
            color: #555;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .loading-item.loading {
            color: #0052cc;
            border-color: #0052cc;
        }
        .loading-item.success {
            border-color: #28a745;
            background-color: #e6f7ec;
            color: #155724;
            font-weight: 600;
            border-style: solid;
        }
        .loading-item.error {
            border-color: #dc3545;
            background-color: #fbeae6;
            color: #721c24;
            font-weight: 600;
            border-style: solid;
        }
        .spinner {
            display: inline-block;
            width: 1em;
            height: 1em;
            vertical-align: -0.125em;
            border: 0.15em solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: 0.75s linear infinite spinner-border;
            margin-right: 5px;
        }
        @keyframes spinner-border {
            to { transform: rotate(360deg); }
        }

        /* Controls */
        #controls-container {
            padding: 30px;
            border-bottom: 1px solid #eee;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .control-group label {
            display: block;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 10px;
        }
        .control-group input[type="text"],
        .control-group select {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* Important for 100% width */
        }
        .control-group input:disabled,
        .control-group select:disabled {
            background-color: #f4f4f4;
            cursor: not-allowed;
        }

        /* View Toggle */
        #view-toggle {
            padding: 20px 30px;
            border-bottom: 1px solid #eee;
            display: none; /* Hidden by default */
        }
        #view-toggle fieldset {
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 15px;
        }
        #view-toggle legend {
            font-weight: 600;
            padding: 0 10px;
            font-size: 1.1em;
        }
        #view-toggle div {
            display: flex;
            justify-content: center;
            gap: 30px;
        }
        #view-toggle label {
            font-size: 1.1em;
            cursor: pointer;
        }

        /* Results */
        #results {
            padding: 30px;
            display: none; /* Hidden by default */
        }
        #results h2 {
            font-size: 1.5em;
            color: #0052cc;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 0;
        }
        #stats-tiles {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-tile {
            background: #f4f7f6;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        .stat-tile-value {
            font-size: 2.5em;
            font-weight: 700;
            color: #0041a3;
            margin: 0;
        }
        .stat-tile-label {
            font-size: 1em;
            color: #555;
            margin: 5px 0 0 0;
        }
        .chart-container {
            margin-top: 30px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        footer {
            text-align: center;
            padding: 20px;
            font-size: 0.9em;
            color: #888;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <header>
            <h1>Athlete Performance Analyzer</h1>
        </header>

        <section id="loading-status">
            <div id="loading-race" class="loading-item loading">
                <span class="spinner"></span> <strong>Loading Race Data...</strong>
            </div>
            <div id="loading-dob" class="loading-item loading">
                <span class="spinner"></span> <strong>Loading DOB Data...</strong>
            </div>
            <div id="loading-benchmark" class="loading-item loading">
                <span class="spinner"></span> <strong>Loading Benchmarks...</strong>
            </div>
        </section>

        <section id="controls-container">
            <div class="control-group">
                <label for="class-select">Select Class</label>
                <select id="class-select" disabled>
                    <option value="">-- Loading Data --</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="athlete-search">Search Athlete</label>
                <input type="text" id="athlete-search" placeholder="-- Select Class First --" disabled>
            </div>

            <div class="control-group">
                <label for="athlete-select">Select Athlete</label>
                <select id="athlete-select" disabled>
                    <option value="">-- Select Class First --</option>
                </select>
            </div>
        </section>

        <section id="view-toggle">
            <fieldset>
                <legend>View Data By</legend>
                <div>
                    <label>
                        <input type="radio" name="viewBy" value="year" checked> By Year
                    </label>
                    <label>
                        <input type="radio" name="viewBy" value="age" id="view-by-age-radio" disabled> By Age
                    </Dlabel>
                </div>
            </fieldset>
        </section>

        <section id="results">
            <h2 id="athlete-name-display"></h2>
            
            <div id="stats-tiles">
                <div class="stat-tile">
                    <p class="stat-tile-value" id="total-races"></p>
                    <p class="stat-tile-label">Total Unique Races</p>
                </div>
                <div class="stat-tile">
                    <p class="stat-tile-value" id="first-year"></p>
                    <p class="stat-tile-label">First Year</p>
                </div>
                <div class="stat-tile">
                    <p class="stat-tile-value" id="last-year"></p>
                    <p class="stat-tile-label">Last Year</p>
                </div>
            </div>

            <div class="chart-container">
                <canvas id="racesPerYearChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="cumulativeRacesChart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="avgQualityPenaltyChart"></canvas>
            </div>
        </section>
        
        <footer>
            Application built by Slalom Performance Support.
        </footer>
    </div>

    <script>
        // === Global Data Stores ===
        let allData = [];
        let dobData = {}; // Stores { "NORM_NAME": birthYear }
        let benchmarkData = {};
        let classAthleteMap = {}; // Stores { "WC1": [{ name, normName }, ...] }
        let athleteBirthYear = null; // Birth year of the *selected* athlete
        let chartInstances = {};
        
        // --- Data Loaded Flags ---
        let dobDataLoaded = false;
        let benchmarkDataLoaded = false;

        // === GitHub Repo Details ===
        const GITHUB_USER = "NickPez36";
        const GITHUB_REPO = "CSL-Racing-Experience";
        const GITHUB_BRANCH = "main"; // Assuming default branch is 'main'

        // === File Paths ===
        const RACE_DATA_PATH = `data/2014-2025-WC1-all_wr_data.json`;
        const DOB_DATA_PATH = `data/dob_list.json`;
        const BENCHMARK_DATA_PATH = `data/benchmarks.json`;

        // === DOM Elements ===
        const loadingRace = document.getElementById('loading-race');
        const loadingDob = document.getElementById('loading-dob');
        const loadingBenchmark = document.getElementById('loading-benchmark');
        
        const classSelect = document.getElementById('class-select');
        const athleteSearch = document.getElementById('athlete-search');
        const athleteSelect = document.getElementById('athlete-select');
        
        const viewToggle = document.getElementById('view-toggle');
        const viewByYearRadio = document.querySelector('input[value="year"]');
        const viewByAgeRadio = document.getElementById('view-by-age-radio');
        
        const resultsSection = document.getElementById('results');

        // === 1. Data Fetching on Load ===
        window.addEventListener('DOMContentLoaded', loadAllData);

        /**
         * Fetches a file from the GitHub repo
         */
        async function fetchFile(filePath, statusElement, fileLabel) {
            const url = `https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/${GITHUB_BRANCH}/${filePath}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const jsonData = await response.json();
                statusElement.textContent = `${fileLabel} Loaded`;
                statusElement.className = 'loading-item success';
                return jsonData;
            } catch (error) {
                console.error(`Error fetching ${fileLabel}:`, error);
                statusElement.textContent = `${fileLabel} Failed to Load`;
                statusElement.className = 'loading-item error';
                throw error; // Re-throw to be caught by Promise.allSettled
            }
        }

        /**
         * Main function to load all data sources
         */
        async function loadAllData() {
            // Use Promise.allSettled to ensure all fetches complete, even if one fails
            const results = await Promise.allSettled([
                fetchFile(RACE_DATA_PATH, loadingRace, "Race Data"),
                fetchFile(DOB_DATA_PATH, loadingDob, "DOB Data"),
                fetchFile(BENCHMARK_DATA_PATH, loadingBenchmark, "Benchmarks")
            ]);

            // --- Process Race Data (Critical) ---
            if (results[0].status === 'fulfilled') {
                allData = results[0].value;
                processRaceData();
                
                // Enable class dropdown
                classSelect.disabled = false;
                
                // Populate class dropdown
                const classes = Object.keys(classAthleteMap).sort();
                classSelect.innerHTML = '<option value="">-- Select a Class --</option>';
                classes.forEach(cls => {
                    const option = document.createElement('option');
                    option.value = cls;
                    option.textContent = cls;
                    classSelect.appendChild(option);
                });
            } else {
                classSelect.innerHTML = '<option value="">-- RACE DATA FAILED --</option>';
                console.error("Failed to load critical race data.");
            }

            // --- Process DOB Data (Optional but recommended) ---
            if (results[1].status === 'fulfilled') {
                const dobJson = results[1].value;
                dobData = {}; // Clear old data
                for (const athlete of dobJson) {
                    const normName = normalizeName(athlete.athlete_name);
                    if (normName && athlete.birth_year) {
                        dobData[normName] = parseInt(athlete.birth_year);
                    }
                }
                dobDataLoaded = true;
            }

            // --- Process Benchmark Data (Optional) ---
            if (results[2].status === 'fulfilled') {
                benchmarkData = results[2].value;
                benchmarkDataLoaded = true;
            }
        }


        // === 2. Data Processing and Controls ===

        /**
         * Normalizes "First LAST" or "LAST, First" to "LAST,FIRST"
         */
        function normalizeName(name) {
            if (!name) return "";
            let firstName, lastName;
            name = name.trim();
            
            if (name.includes(',')) {
                // Format: "LAST, First"
                const parts = name.split(',');
                lastName = parts[0].trim();
                firstName = parts.length > 1 ? parts[1].trim() : "";
            } else {
                // Format: "First LAST", "LAST First", or "First Last"
                const parts = name.split(' ');
                if (parts.length === 1) {
                    // Only one name, treat it as last name
                    lastName = parts[0];
                    firstName = "";
                } else {
                    // Check for all-caps lastname, e.g., "Jessica FOX" or "POLLERT Lukas"
                    const isAllCaps = parts.map(p => p.length > 1 && p === p.toUpperCase());
                    
                    if (isAllCaps[0] && !isAllCaps[1]) {
                        // Format: "LAST First", e.g., "CLEMENTS Claire" or "POLLERT Lukas"
                        lastName = parts[0];
                        firstName = parts.slice(1).join(' ');
                    } else if (!isAllCaps[0] && isAllCaps[isAllCaps.length - 1]) {
                        // Format: "First LAST", e.g., "Jessica FOX"
                        lastName = parts.pop();
                        firstName = parts.join(' ');
                    } else {
                        // Default: Assume "First Last" format, e.g., "Claire Clements"
                        lastName = parts.pop();
                        firstName = parts.join(' ');
                    }
                }
            }
            return `${lastName.toUpperCase()},${firstName.toUpperCase()}`;
        }
        
        /**
         * Processes raw race data to build the Class -> Athlete map
         */
        function processRaceData() {
            const athleteNameCache = new Map(); // Cache for name normalization
            classAthleteMap = {};

            allData.forEach(entry => {
                if (!entry.class || !entry.athlete_name) return;

                const cls = entry.class;
                const name = entry.athlete_name;
                let normName;

                if (athleteNameCache.has(name)) {
                    normName = athleteNameCache.get(name);
                } else {
                    normName = normalizeName(name);
                    athleteNameCache.set(name, normName);
                }

                if (!classAthleteMap[cls]) {
                    classAthleteMap[cls] = new Map();
                }

                if (!classAthleteMap[cls].has(normName)) {
                    classAthleteMap[cls].set(normName, name); // Store original name for display
                }
            });

            // Convert map to sorted array
            for (const cls in classAthleteMap) {
                const athleteMap = classAthleteMap[cls];
                classAthleteMap[cls] = Array.from(athleteMap.entries())
                    .map(([normName, name]) => ({ name, normName }))
                    .sort((a, b) => a.name.localeCompare(b.name));
            }
        }
        
        // --- Control Listeners ---

        // Class selection: Populates athlete list
        classSelect.addEventListener('change', () => {
            const selectedClass = classSelect.value;
            athleteSearch.value = ''; // Clear search
            
            if (selectedClass) {
                const athletes = classAthleteMap[selectedClass] || [];
                populateAthleteSelect(athletes);
                athleteSearch.disabled = false;
                athleteSearch.placeholder = `Search ${athletes.length} athletes...`;
                athleteSelect.disabled = false;
            } else {
                populateAthleteSelect([]); // Clear
                athleteSearch.disabled = true;
                athleteSearch.placeholder = '-- Select Class First --';
                athleteSelect.disabled = true;
            }
            // Hide results when class changes
            resultsSection.style.display = 'none';
            viewToggle.style.display = 'none';
        });

        // Athlete search: Filters athlete dropdown
        athleteSearch.addEventListener('input', () => {
            const searchTerm = athleteSearch.value.toLowerCase();
            const selectedClass = classSelect.value;
            if (!selectedClass) return;

            const allAthletes = classAthleteMap[selectedClass];
            const filteredAthletes = allAthletes.filter(athlete => 
                athlete.name.toLowerCase().includes(searchTerm)
            );
            populateAthleteSelect(filteredAthletes);
        });

        // Athlete selection: Triggers analysis
        athleteSelect.addEventListener('change', () => {
            if (athleteSelect.value) {
                checkAgeToggle();
                analyzeAndDisplay(); // Run the analysis
                
                resultsSection.style.display = 'block';
                viewToggle.style.display = 'block';
                document.getElementById('athlete-name-display').textContent = `Showing Results for: ${athleteSelect.options[athleteSelect.selectedIndex].text}`;
            } else {
                resultsSection.style.display = 'none';
                viewToggle.style.display = 'none';
            }
        });

        // View By toggle: Re-runs analysis
        [viewByYearRadio, viewByAgeRadio].forEach(radio => {
            radio.addEventListener('change', () => {
                if (resultsSection.style.display === 'block') {
                    analyzeAndDisplay();
                }
            });
        });

        /**
         * Helper to populate athlete select box
         */
        function populateAthleteSelect(athletes) {
            athleteSelect.innerHTML = '<option value="">-- Select an Athlete --</option>';
            athletes.forEach(athlete => {
                const option = document.createElement('option');
                option.value = athlete.normName; // Use normalized name as value
                option.textContent = athlete.name; // Use original name for display
                athleteSelect.appendChild(option);
            });
        }
        
        /**
         * Checks if DOB data exists for selected athlete and enables/disables toggle
         */
        function checkAgeToggle() {
            const selectedNormName = athleteSelect.value;
            athleteBirthYear = dobData[selectedNormName] || null;

            if (athleteBirthYear && dobDataLoaded) {
                viewByAgeRadio.disabled = false;
                viewByAgeRadio.checked = true; // <-- 1. Set 'By Age' as default if available
            } else {
                viewByAgeRadio.disabled = true;
                viewByYearRadio.checked = true; // Default back to 'year'
            }
        }


        // === 3. Analysis & Charting ===

        /**
         * Main analysis function. Gathers data, processes it, and calls chart functions.
         */
        function analyzeAndDisplay() {
            const selectedNormName = athleteSelect.value;
            if (!selectedNormName) return;

            // Step 1: Get all unique races for the selected athlete
            const athleteEntries = allData.filter(entry => normalizeName(entry.athlete_name) === selectedNormName);
            const uniqueRaceStrings = new Set();
            for (const entry of athleteEntries) {
                for (let i = 1; i <= 100; i++) {
                    const raceString = entry[`pointsR${i}`];
                    if (raceString && raceString.trim() !== "") {
                        uniqueRaceStrings.add(raceString);
                    }
                }
            }

            // Step 2: Process unique race strings into structured data
            const processedRaces = [];
            const yearRegex = /\b(19[8-9]\d|20\d{2})\b/g;

            for (const raceString of uniqueRaceStrings) {
                try {
                    const parts = raceString.split(';');
                    if (parts.length < 3) continue;

                    const competition = parts[1].trim();
                    const yearMatches = competition.match(yearRegex);
                    const year = yearMatches ? parseInt(yearMatches[yearMatches.length - 1]) : null;
                    if (!year) continue; // Skip if no year

                    const race = {
                        year: year,
                        competition: competition, // <-- 1. Keep the competition name
                        qualityPenalty: parseFloat(parts[2].replace('qp:', '').trim())
                    };
                    
                    if (athleteBirthYear) {
                        race.age = year - athleteBirthYear;
                    }
                    processedRaces.push(race);
                } catch (e) {
                    console.warn('Could not parse race string:', raceString, e);
                }
            }

            if (processedRaces.length === 0) {
                resultsSection.innerHTML = '<h2>No valid race data found for this athlete.</h2>';
                return;
            }

            // Step 3: Determine view mode (Year vs Age)
            const viewMode = viewByAgeRadio.checked ? 'age' : 'year';
            
            // Step 4: Group data by the selected view mode
            const statsByPeriod = {};
            processedRaces.forEach(race => {
                const period = race[viewMode];
                if (period === undefined || period === null) return; // Skip if no age/year

                if (!statsByPeriod[period]) {
                    statsByPeriod[period] = {
                        races: [], // <-- 2. Store full race objects
                        qpValues: []
                    };
                }
                statsByPeriod[period].races.push(race); // <-- 3. Add the whole race object
                if (!isNaN(race.qualityPenalty)) {
                    statsByPeriod[period].qpValues.push(race.qualityPenalty);
                }
            });

            // Step 5: Create chart data
            const sortedPeriods = Object.keys(statsByPeriod).map(Number).sort((a, b) => a - b);
            const labels = sortedPeriods.map(String); // Chart labels
            
            // --- Athlete's Data ---
            const racesPerPeriod = labels.map(p => statsByPeriod[p].races.length); // <-- 4. Get count from .races.length
            const raceListsByPeriod = labels.map(p => statsByPeriod[p].races.map(r => r.competition)); // <-- 5. Create list of names
            
            const avgQualityPenalty = labels.map(p => {
                const qp = statsByPeriod[p].qpValues;
                return qp.length > 0 ? (qp.reduce((a, b) => a + b, 0) / qp.length) : 0;
            });
            const cumulativeRaces = [];
            let cumulativeTotal = 0;
            for (const count of racesPerPeriod) {
                cumulativeTotal += count;
                cumulativeRaces.push(cumulativeTotal);
            }
            
            // --- Benchmark Data (if loaded) ---
            const benchmarkPeriodData = benchmarkData[viewMode === 'year' ? 'byYear' : 'byAge'];
            let q1_races, q3_races, q1_cum, q3_cum, q1_qp, q3_qp;
            
            if (benchmarkDataLoaded && benchmarkPeriodData) {
                // Map the labels (e.g., "2018", "19") to the benchmark data
                const getBenchmark = (metric, q) => labels.map(p => benchmarkPeriodData[p]?.[metric]?.[q] ?? null);
                
                q1_races = getBenchmark('racesPerPeriod', 'q1');
                q3_races = getBenchmark('racesPerPeriod', 'q3');
                q1_cum = getBenchmark('cumulativeRaces', 'q1');
                q3_cum = getBenchmark('cumulativeRaces', 'q3');
                q1_qp = getBenchmark('avgQualityPenalty', 'q1');
                q3_qp = getBenchmark('avgQualityPenalty', 'q3');
            }
            
            // --- Update Stats Tiles (based on 'year' data, regardless of view mode) ---
            const firstYear = Math.min(...processedRaces.map(r => r.year));
            const lastYear = Math.max(...processedRaces.map(r => r.year));
            document.getElementById('total-races').textContent = processedRaces.length;
            document.getElementById('first-year').textContent = firstYear || 'N/A';
            document.getElementById('last-year').textContent = lastYear || 'N/A';

            // Step 6: Create/Update Charts
            const periodLabel = viewMode === 'year' ? 'Year' : 'Age';

            // Races per Period (Bar Chart)
            updateChart('racesPerYearChart', {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        createBenchmarkDataset('Medallist Band (Q1-Q3)', q1_races, q3_races, 'rgba(130, 130, 130, 0.35)'), // <-- Darker color
                        {
                            label: `Races per ${periodLabel}`,
                            data: racesPerPeriod,
                            competitionNames: raceListsByPeriod, // <-- 6. Pass race names to dataset
                            backgroundColor: 'rgba(0, 82, 204, 0.7)',
                            borderColor: 'rgba(0, 82, 204, 1)',
                            borderWidth: 1,
                            order: 3 // <-- Changed order to 3 (draws on top)
                        }
                    ].filter(Boolean) // Remove null benchmark dataset if it doesn't exist
                },
                options: {
                    scales: { 
                        x: { title: { display: true, text: periodLabel } },
                        y: { beginAtZero: true, title: { display: true, text: 'Number of Races' } } 
                    },
                    plugins: { 
                        title: { display: true, text: `Races Completed per ${periodLabel}`, font: { size: 16 } },
                        tooltip: { // <-- 7. Add custom tooltip
                            footerSpacing: 4,
                            footerAlign: 'left',
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.isBenchmark) return; 
                                    return context.dataset.label + ': ' + context.formattedValue;
                                },
                                footer: function(tooltipItems) {
                                    if (!tooltipItems.length) return '';
                                    const context = tooltipItems[0];
                                    const dataIndex = context.dataIndex;
                                    const dataset = context.chart.data.datasets[context.datasetIndex];
                                    
                                    // Retrieve our custom data
                                    const raceNames = dataset.competitionNames ? dataset.competitionNames[dataIndex] : null;

                                    if (raceNames && raceNames.length > 0) {
                                        const listItems = raceNames.map(name => {
                                            // Truncate long names
                                            const shortName = name.length > 40 ? name.substring(0, 37) + '...' : name;
                                            return `• ${shortName}`;
                                        });
                                        return [`\nRaces in this period:`, ...listItems];
                                    }
                                    return ''; 
                                }
                            }
                        }
                    }
                }
            });

            // Cumulative Races (Line Chart)
            updateChart('cumulativeRacesChart', {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        createBenchmarkDataset('Medallist Q1', q1_cum, q1_cum, 'rgba(130, 130, 130, 0.1)', 'rgba(130, 130, 130, 0.7)', 0, true), // <-- Darker base color
                        createBenchmarkDataset('Medallist Q3', q3_cum, q3_cum, 'rgba(130, 130, 130, 0.35)', 'rgba(130, 130, 130, 0.7)', 0, true, '-1'), // <-- Darker fill color
                        {
                            label: 'Cumulative Races',
                            data: cumulativeRaces,
                            backgroundColor: 'rgba(0, 131, 14, 0.1)',
                            borderColor: 'rgba(0, 131, 14, 1)',
                            fill: false, // Athlete line should not be filled
                            tension: 0.1,
                            order: 1
                        }
                    ].filter(Boolean)
                },
                options: {
                    scales: { 
                        x: { title: { display: true, text: periodLabel } },
                        y: { beginAtZero: true, title: { display: true, text: 'Total Races' } } 
                    },
                    plugins: { 
                        title: { display: true, text: `Cumulative Races by ${periodLabel}`, font: { size: 16 } },
                        tooltip: { mode: 'index', intersect: false },
                        filler: { propagate: false } // Important for line chart bands
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    }
                }
            });
            
            // Average Quality Penalty (Bar Chart)
            updateChart('avgQualityPenaltyChart', {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        createBenchmarkDataset('Medallist Band (Q1-Q3)', q1_qp, q3_qp, 'rgba(130, 130, 130, 0.35)'), // <-- Darker color
                        {
                            label: 'Average Quality Penalty',
                            data: avgQualityPenalty,
                            competitionNames: raceListsByPeriod, // <-- 8. Pass race names to dataset
                            backgroundColor: 'rgba(214, 51, 0, 0.7)',
                            borderColor: 'rgba(214, 51, 0, 1)',
                            borderWidth: 1,
                            order: 3, // <-- Changed order to 3 (draws on top)
                            minBarLength: 5 // <-- THIS IS THE FIX
                        }
                    ].filter(Boolean)
                },
                options: {
                    scales: { 
                        x: { title: { display: true, text: periodLabel } },
                        y: { beginAtZero: true, title: { display: true, text: 'Average QP' } } 
                    },
                    plugins: { 
                        title: { display: true, text: `Average Quality Penalty per ${periodLabel}`, font: { size: 16 } },
                        tooltip: { // <-- 9. Add custom tooltip (same logic)
                            footerSpacing: 4,
                            footerAlign: 'left',
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.isBenchmark) return; 
                                    return context.dataset.label + ': ' + context.formattedValue;
                                },
                                footer: function(tooltipItems) {
                                    if (!tooltipItems.length) return '';
                                    const context = tooltipItems[0];
                                    const dataIndex = context.dataIndex;
                                    const dataset = context.chart.data.datasets[context.datasetIndex];
                                    
                                    const raceNames = dataset.competitionNames ? dataset.competitionNames[dataIndex] : null;

                                    if (raceNames && raceNames.length > 0) {
                                        const listItems = raceNames.map(name => {
                                            const shortName = name.length > 40 ? name.substring(0, 37) + '...' : name;
                                            return `• ${shortName}`;
                                        });
                                        return [`\nRaces in this period:`, ...listItems];
                                    }
                                    return ''; 
                                }
                            }
                        }
                    }
                }
            });
        }
        
        /**
         * Creates a benchmark dataset for Chart.js
         * For Bar charts, q1Data is Q1 and q2Data is Q3
         * For Line charts (bands), q1Data is lower bound, q2Data is upper bound
         */
        function createBenchmarkDataset(label, q1Data, q3Data, bgColor, borderColor, borderWidth, isLine, fillTarget) {
            if (!q1Data || !q3Data) return null; // Data not loaded

            if (isLine) {
                // Line chart band
                return {
                    label: label,
                    data: q1Data, // Use Q1 as the data, Q3 as the fill target
                    borderColor: borderColor || 'transparent',
                    backgroundColor: bgColor,
                    borderWidth: borderWidth || 0,
                    pointRadius: 0,
                    fill: fillTarget || false,
                    isBenchmark: true,
                    order: 3
                };
            } else {
                // Bar chart band (uses 'floating' bars)
                const floatingData = q1Data.map((q1, i) => (q1 !== null && q3Data[i] !== null) ? [q1, q3Data[i]] : null);
                return {
                    label: label,
                    data: floatingData,
                    backgroundColor: bgColor,
                    borderColor: bgColor,
                    borderWidth: 1,
                    isBenchmark: true,
                    order: 2 // <-- 2. Changed order to 2 (draws behind athlete)
                };
            }
        }

        /**
         * Helper function to create or update a Chart.js instance
         * This prevents charts from being re-rendered on top of each other.
         */
        function updateChart(canvasId, config) {
            if (chartInstances[canvasId]) {
                chartInstances[canvasId].destroy();
            }
            const ctx = document.getElementById(canvasId).getContext('2d');
            chartInstances[canvasId] = new Chart(ctx, config);
        }

    </script>
</body>
</html>
